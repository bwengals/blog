<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="BE">
<meta name="dcterms.date" content="2024-06-26">
<meta name="description" content="Post description">

<title>Bill Engels’ Web Log - What is a Gaussian Process?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Bill Engels’ Web Log</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/bwengals"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">What is a Gaussian Process?</h1>
                  <div>
        <div class="description">
          Post description
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>BE </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 26, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div id="3a74acb8-7e60-477e-926c-cc322ac86331" class="cell" data-editable="true" data-slideshow="{&quot;slide_type&quot;:&quot;&quot;}" data-tags="[]" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc <span class="im">as</span> pm</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytensor.tensor <span class="im">as</span> pt</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> patsy <span class="im">as</span> pt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="todo" class="level1">
<h1>TODO</h1>
<ul>
<li>remove TVP mentions</li>
<li>rewrite</li>
<li>Last section, dont introduce other covariances, just play with the lengthscale</li>
<li>switch to talking about correlation, so we dont need amplitude. MAYBE</li>
</ul>
</section>
<section id="gp-overview" class="level1">
<h1>GP Overview</h1>
<p>Gaussian processes are a technique for fitting curves and then making forecasts. They can serve a similar purpose as polynomials or splines – but unlike polynomials or splines, they also can be used for forecasting, like autoregressive and random walk models. GPs are very general. Splines, polynomials, autoregressive and random walk models can all be expressed as a GP. Another advantage is Gaussian processes scale well with input dimension. For instance, a time series is one-dimensional, and a spatial process is 2D. A spatially varying process that also depends on 3 other covariates is 5D. GPs can handle this easily, with full interactions between the dimensions.</p>
<p>The catch is that they scale very poorly with the number of data points, <span class="math inline">\(n\)</span>, both for fitting and prediction. Their computational complexity is <span class="math inline">\(\mathcal{O}(n^3)\)</span>. The game with using GPs in practice is using approximations to GPs. I think this is what scares most people away from using them more extensively. There are many different approximations, but each one is designed to work well in specific situations. The Hilbert space Gaussian process approximation (HSGP) works great for one or two dimensional inputs, so a time series or a spatial process, and with covariance functions that are stationary. The most useful stationary covariance functions are those in are in the Matern family, so <code>pm.gp.cov.ExpQuad</code>, <code>pm.gp.cov.Matern52</code>, <code>pm.gp.cov.Matern32</code>. Computationally, HSGPs scale with data set size <span class="math inline">\(n\)</span> more like spline models, so they are very fast to fit. They were intended to be used within probablistic programming languages, like PyMC and Stan, because one or two dimensional Matern GPs are really useful as components in larger models.</p>
<p>(HS)GPs are a good fit for TVPs because unlike splines or polynomials you can forecast with them, and unlike AR processes or random walks, they are generally smoother and it’s much easier to include prior information about how we think the TVPs behave. The restrictions that HSGPs carry aren’t an issue for making TVPs in an MMM model. We’ll just stick to one dimensional examples here, because that’s what you need for a TVP.</p>
</section>
<section id="what-is-a-gp" class="level1">
<h1>What is a GP?</h1>
<p>You’re probably used to the idea of putting a prior on some unknown parameter. At the simplest level, a Gaussian process is a multivariate normal (Gaussian) prior on some unknown vector. That’s the “G” in the “GP”. The process part, the “P”, is that you have to use a covariance <em>function</em>, instead of a covariance <em>matrix</em>. Here’s the difference between a covariance matrix and a covariance function in a context where you have <span class="math inline">\(n=3\)</span> data points. This would be analogous to modeling a TVP over three days.</p>
<section id="covariance-matrix" class="level3">
<h3 class="anchored" data-anchor-id="covariance-matrix">Covariance matrix</h3>
<p>Say you have a length 3 vector that you don’t know, call it <code>f</code>. This could be one of the parameters in the Tanh or Michaelis-Menten saturation function. One option is to put three independent normal priors on each element of <span class="math inline">\(f\)</span>. This wont work very well though, because we know that the values of <code>f</code> are not independent, because they probably change somewhat slowly over time. Instead, we can put a multivariate normal prior on it to account for the lack of independence. The multivariate normal distribution is parameterized by a mean vector and a covariance matrix. We always assume the mean vector equals zero and forget about it. For a length 3 vector, the covariance matrix will be 3-by-3, and each element gives the covariance between the <span class="math inline">\(i\)</span>th and <span class="math inline">\(j\)</span>th element of the vector <code>f</code>.</p>
<p>Before we can use our multivariate normal prior in a model, we need to choose the values of the covariance matrix. Say you think, a-priori, that there is a pretty strong relationship between successive elements, as one would for a TVP. If it equals a particular value on Tuesday, it’s probably going to be at a similar value on Wednesday. It could change drastically, but it’s more likely that it won’t. Other than that they are positive, you may not know much about the actual values per se, just that if <code>f[0]</code> is high, then <code>f[1]</code> is probably high, too. Also if you think <code>f[1]</code> is low, then <code>f[2]</code> is probably also low. This is just positive correlation. It’s also reasonable to think a-priori that there’s two-step correlation, so that if <code>f[0]</code> is high then so is <code>f[2]</code>, but that the two-step correlation is not as strong as the one-step correlation.</p>
<p>The prior below expresses this for the particular choices of 0.7 for the one-step correlation and 0.1 for the two step correlation. We can then draw 4 samples from this prior below.</p>
<div id="39cf088c-0d66-40ce-9112-96dde3c4f97f" class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>covariance_matrix <span class="op">=</span> np.array([</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.0</span>, <span class="fl">0.7</span>, <span class="fl">0.1</span>],</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.7</span>, <span class="fl">1.0</span>, <span class="fl">0.7</span>],</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.1</span>, <span class="fl">0.7</span>, <span class="fl">1.0</span>],</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">3</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> pm.draw(pm.MvNormal.dist(mu<span class="op">=</span>np.zeros(<span class="dv">3</span>), cov<span class="op">=</span>covariance_matrix), <span class="dv">4</span>).T</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>plt.plot(x, samples)<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"x"</span>)<span class="op">;</span> plt.ylabel(<span class="st">"f"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="what-is-a-GP_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>You could code this up in PyMC and it would work great. There are some clear drawbacks though:</p>
<ol type="1">
<li>This is tedious. If you had a vector of length 10, it’d be difficult to decide on your a-priori assumptions on what all the covariance values should be. Or if you had a vector of length 1000.</li>
<li>There’s no mechanism to forecast the TVP past the observed days. How would you get the 4th point? The only way to do it is to assume that the one and two-step correlations you chose held true. What about three-step correlation? We need that now, and we’d have to make up a new number for it. The assumption is kind of sketchy. It’d be far better to use the actual data to determine this somehow. We’ll return to this later when talking about the lengthscale parameter.</li>
</ol>
<p>These two issues lead us to covariance <em>functions</em>.</p>
</section>
<section id="covariance-function" class="level3">
<h3 class="anchored" data-anchor-id="covariance-function">Covariance function</h3>
<p>A covariance <em>function</em> takes in two arbitrary x-locations, we’ll call them <span class="math inline">\(x\)</span> and <span class="math inline">\(x'\)</span>, so it knows how far apart each element in the vector is, and given those two x-locations it then returns the covariance value that <code>f</code> should have between these two locations. To make a covariance <em>matrix</em>, we have to iterate over all possible combinations of <span class="math inline">\(x\)</span> to calculate all the pairs (maybe you’re starting to see why GPs are so slow). Our example covariance function is: <span class="math display">\[
k(x, x') = \exp\left( -(x - x')^2 \right)
\]</span></p>
<ul>
<li><span class="math inline">\((x - x')^2\)</span> is the squared “distance” between the two x-locations.<br>
</li>
<li>Taking the negative and exponentiating the distance makes it so that small distances go to 1, and large distances go to 0.</li>
</ul>
<p>We can pass in any <span class="math inline">\(x\)</span> to our covariance function and get a covariance matrix. Passing over the actual math, this is the groundwork that we need to use multivariate normals for forecasting, the “process” part of Gaussian process.</p>
<div id="72c8607c-01db-4b05-97ec-7bf5223a2b7a" class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> covariance_function(x, x_prime):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> np.square(x <span class="op">-</span> x_prime)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> dist)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> np.empty((<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        K[i, j] <span class="op">=</span> covariance_function(x[i], x[j])</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> pm.draw(pm.MvNormal.dist(mu<span class="op">=</span>np.zeros(<span class="dv">3</span>), cov<span class="op">=</span>K), <span class="dv">4</span>).T</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>plt.plot(x, samples)<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"x"</span>)<span class="op">;</span> plt.ylabel(<span class="st">"f"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="what-is-a-GP_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="b6fe9cd3-2754-4727-a566-8e52de530b3c" class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(K)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1.         0.36787944 0.01831564]
 [0.36787944 1.         0.36787944]
 [0.01831564 0.36787944 1.        ]]</code></pre>
</div>
</div>
<p>The covariance matrix that come out of the covariance function is pretty similar to the first one that we made up. It contains the same idea, that successive elements of <code>f</code> are more correlated than elements that are further apart. Since we wrote a covariance <em>function</em>, let’s pass in a much larger vector <code>x</code>, 100 points equally spaced between <span class="math inline">\(x=0\)</span> and <span class="math inline">\(x=3\)</span>, and see what our prior samples look like now.</p>
<div id="15b5a6fd-b331-430a-92e5-21b56bc373f4" class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">3</span>, n)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> covariance_function(x, x_prime):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> np.square(x <span class="op">-</span> x_prime)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> dist)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> np.empty((n, n))</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        K[i, j] <span class="op">=</span> covariance_function(x[i], x[j])</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> pm.draw(pm.MvNormal.dist(mu<span class="op">=</span>np.zeros(n), cov<span class="op">=</span>K), <span class="dv">4</span>).T</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>plt.plot(x, samples)<span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"x"</span>)<span class="op">;</span> plt.ylabel(<span class="st">"f"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="what-is-a-GP_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Our original <code>x</code> was three elements long, and our new <code>x</code> is 100 elements long, both going from 0 to 3, but this one has a much higher resolution. This leads to prior samples of <code>f</code> that also have a much higher resolution. This gives us an entirely new way to think about functions, via the correlation between successive elements, instead of trying to construct them from existing functions like lines, polynomials, or sine waves. When designing priors for GPs, you think about how closeness between different pairs <span class="math inline">\(x\)</span> and <span class="math inline">\(x'\)</span> points manifests in closeness of <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(f(x')\)</span>. It seems strange at first, but I think it’s a much more natural way to think about putting priors on unknown functions. TVPs in an MMM definitely don’t really follow sine or polynomial patterns, but a value for a particular day really is more related to the value on nearby days. By thinking more carefully about that relation, we can include more prior knowledge about the TVP into the model that will improve it’s results.</p>
</section>
<section id="the-lengthscale-parameter" class="level3">
<h3 class="anchored" data-anchor-id="the-lengthscale-parameter">The lengthscale parameter</h3>
<p>There’s one more very important piece missing. Our covariance function currently has a fixed sense of nearness between pairs of <span class="math inline">\(x\)</span> values. Let’s change that by introducing a parameter called the lengthscale. Then, we replace the distance, <span class="math inline">\((x - x)^2\)</span> with <span class="math inline">\(\left(\frac{x - x'}{\ell} \right)^2\)</span>. The lengthscale <span class="math inline">\(\ell\)</span> directly scales the distance between the pair of <span class="math inline">\(x\)</span> values. Our new covariance function is<br>
<span class="math display">\[
k(x, x') = \exp\left( -\frac{(x - x')^2}{\ell^2} \right) \,.
\]</span> The Python code for it is below.</p>
<div id="44c66882-07f0-4cfa-b8b3-b93b3fba325f" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> covariance_function(x, x_prime, ell):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> np.square(x <span class="op">-</span> x_prime) <span class="op">/</span> np.square(ell)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> dist)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For instance, if <span class="math inline">\(x = 0\)</span> and <span class="math inline">\(x' = 10\)</span>, then a lengthscale of <span class="math inline">\(\ell = 100\)</span> gives,</p>
<div id="cc409503-01a5-4ad2-b6c0-ef63c05ecc74" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>covariance_function(x<span class="op">=</span><span class="dv">0</span>, x_prime<span class="op">=</span><span class="dv">10</span>, ell<span class="op">=</span><span class="dv">100</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>0.9900498337491681</code></pre>
</div>
</div>
<p>which is nearly equal to one. This means that, in the context of <span class="math inline">\(\ell = 100\)</span>, 0 and 10 are actually very close together. Now, say the lengthscale <span class="math inline">\(\ell = 0.5\)</span>. That gives,</p>
<div id="58d93baf-e1f7-4370-820f-aece8a00dc8f" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>covariance_function(x<span class="op">=</span><span class="dv">0</span>, x_prime<span class="op">=</span><span class="dv">10</span>, ell<span class="op">=</span><span class="fl">0.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>1.9151695967140057e-174</code></pre>
</div>
</div>
<p>which is very nearly equal to zero. An analogy might be, San Diego and LA are very far apart – if you’re walking. That’s like having a small lengthscale. San Diego and LA are really close if you’re flying, a large lengtscale. They’re so close it doesn’t make sense to fly. If you’re driving, that’s like having a lengthscale somewhere in the middle. With a lengthscale of 5, we get,</p>
<div id="7f986821-0f34-48aa-9d0a-d884b987aaa3" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>covariance_function(x<span class="op">=</span><span class="dv">0</span>, x_prime<span class="op">=</span><span class="dv">10</span>, ell<span class="op">=</span><span class="fl">10.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>0.3678794411714424</code></pre>
</div>
</div>
<p>Which is a number thats more nicely in the middle between zero and one.</p>
<p>Instead of choosing a value of the lengthscale a-priori, you can put a prior on it and learn it from the data. The lengthscale is, by far, the most important parametern to consider when you’re working with GPs. It’s also a very interpretable parameter. It tells you how far correlations between neighboring <span class="math inline">\(x\)</span> values reach.</p>
<p>More importantly, the lengthscale also tells you have far into the future you can make reliable forecasts. For instance, say <span class="math inline">\(x\)</span> is measured in days. If we were to estimate that the lengthscale is somewhere around 5, that tells us that the relationship between neighboring <span class="math inline">\(x\)</span> values only matters when they’re about 5 days apart. That means that we can probably say something about a forecast 5 days into the future, but beyond that we will have no idea.</p>
</section>
</section>
<section id="drawing-from-the-gp-prior" class="level1">
<h1>Drawing from the GP prior</h1>
<p>There are three degrees of freedom when setting up a GP prior: 1. Choice of kernel or covariance function (kernel or covariance function mean essentially the same thing). One of <code>pm.gp.cov.ExpQuad</code>, <code>pm.gp.cov.Matern52</code>, <code>pm.gp.cov.Matern32</code>. There are many, many different but these three are very useful and are implemented to work with the HSGP approximation. This choice determines how “smooth” the GP is. 2. Choice of lengthscale prior. I usually call it <code>ell</code>, because it has three letters like <code>eta</code> so the code lines up and the Latex command for scripty <span class="math inline">\(\ell\)</span> is “”. This parameter controls how “wiggly” the GP is.<br>
3. Choice of the scale, or amplitude prior. I usually call it <code>eta</code>, which seems to be the convention in Stan. Since a GP is fancy multivariate normal distribution, the scale parameter is called <span class="math inline">\(\eta\)</span> because it’s interpretation is exactly like a standard deviation parameter. I haven’t mentioned it so far because it’s the simplest parameter to understand. It controls whether the GP ranges from -1 to 1, or -100 to 100, or any other scale.</p>
<p>You choose the covariance function, and then set priors on <code>eta</code> and <code>ell</code>. You’ll notice I’m using the words “smoothness” and “wigglyness” as distinct concepts even though they mean the same thing, but hopefully it’s clear why is in a moment. Here I’m also going to switch to the PyMC implementations of the covariance functions. They’re vectorized so we don’t need to use two for loops to evaluate them over the inputs <span class="math inline">\(x\)</span>. The plot below is nine panels, each row is one of the 3 common covariance functions, and each column is a different lengthscale. We’ll use the same vector of x values between 0 and 10 that we used before.</p>
<div id="f38cf427-1672-4181-9187-32c41ff116f1" class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">11</span>))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>cov_funcs <span class="op">=</span> [</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    pm.gp.cov.ExpQuad,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    pm.gp.cov.Matern52,</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    pm.gp.cov.Matern32,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>lengthscales <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">2.0</span>, <span class="fl">15.0</span>]</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        ell <span class="op">=</span> lengthscales[i]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        cov_func <span class="op">=</span> cov_funcs[j](input_dim<span class="op">=</span><span class="dv">1</span>, ls<span class="op">=</span>ell)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        K <span class="op">=</span> cov_func(x[:, <span class="va">None</span>])</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        samples <span class="op">=</span> pm.draw(pm.MvNormal.dist(mu<span class="op">=</span>np.zeros(<span class="bu">len</span>(x)), cov<span class="op">=</span>K), <span class="dv">4</span>).T</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>        axs[i, j].plot(x, samples)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        axs[i, j].set_ylim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>])</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        axs[i, j].set_xlim([<span class="dv">0</span>, <span class="dv">10</span>])</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        axs[i, j].set_title(<span class="ss">f"</span><span class="sc">{</span>cov_funcs[j]<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">, lengthscale=</span><span class="sc">{</span>ell<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>            axs[i, j].set_xlabel(<span class="st">"x"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="what-is-a-GP_files/figure-html/cell-11-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>All the samples in each row are the same amount of “wiggly” (not a technical term), and all the samples in each column are the same amount of “smooth” (a bit more of a technical term). The interpretation of the lengthscale is the same for each covariance function. Our example covariance function we made from scratch is called the “exponentiated quadratic” (kind of a mouthful). It’s implemented in PyMC as <code>pm.gp.cov.ExpQuad</code>. There are many different <a href="https://www.pymc.io/projects/examples/en/latest/gaussian_processes/GP-MeansAndCovs.html#covariance-functions">covariance functions implemented in PyMC</a>. We’ll stick to these three though, since we need to use the HSGP approximation to implement TVPs and it only is built to work with these three (for now). Covariance functions are also called kernels in other contexts. For example, these are the same kernels used with support vector machines, where the exponentiated quadratic is the most common default choice (it’s usually called RBF).</p>
<p>In most applications, the best starting choice is the <code>Matern52</code>. It’s not as rough and choppy as the <code>Matern32</code>, and it’s not as smooth as <code>ExpQuad</code>. Most examples you’ll see in other places use <code>ExpQuad</code> as the default kernel, I think mostly because it has a simple and easy to understand equation. However, it doesn’t make a good default choice because it’s <em>too smooth</em>. Sample functions drawn from exponentiated quadratic priors are actually infinitely differentiable, while samples from the two other Materns are not. Enforcing that the functions are infinitely differentiable is actually a very strong prior on the smoothness of the process you’re modeling, that may not line up with reality. Choosing the <code>Matern52</code> and accepting small amounts of discontinuity is usually a much safer bet.</p>
<p>In a separate notebook I’ll write about how to fit a GP. This will cover the considerations to make when setting priors on the scale and lengthscale parameters, which is critical for getting good results with GPs.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>